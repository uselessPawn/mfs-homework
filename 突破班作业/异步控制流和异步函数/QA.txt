问答题：
1. 为什么要使用 generator 函数 或者 async/await 进行异步控制流，对比 callback 和 Promise 方案，主要解决了什么问题？
为了解决JS用事件+回调函数的机制满足异步操作，导致异步操作多了以后，代码横向发展，嵌套层数太多，导致难以调试和阅读。
Promise虽然能够解决回调地狱的问题，但是代码过于冗长。


2. generator 函数为什么能实现异步控制流？其原理是什么？



3. 什么是 Thunk 函数？为什么使用 Thunk 函数可以通过和 generator 函数配合实现异步控制流？



4. 使用 Promise 可以配合 generator 函数实现异步控制流吗？具体原理是什么？



5. 真正发出异步操作指令是在 generator 函数外还是在 generator 函数内？（hint: 基于 Thunk 函数和基于 Promise 两种 generator 函数异步控制流，情况不一样）



6. async 函数是什么？它和 generator 函数有什么关系？



7. 在全局域或者普通函数中能使用 await 或 yield 关键字吗？为什么？



8. 直接调用 async 函数的返回值类型是什么？为什么？



9. 下面代码能正常捕获异步异常吗？为什么？如果不能需要怎样修改才可以正常捕获异常？
```
async function f() {
   throw new Error('出错了');
}
try{
   f()
}catch(e){
   console.log(e)
}
```

代码题：
1. 请实现 thunkify(fn) 函数，它将一个 callback 类型的异步调用函数转换为 Thunk 函数


2. 请将 fs.readFile(path[, options], callback) 函数 Thunk 化，了解函数点击这里


3. 请实现基于 Thunk 函数的 generator 函数自动运行器


4. 请实现基于 Promise 的 generator 函数自动运行器


5. 请使用之前作业：Promise 实现的 ajaxGet(url) 使用 generator 函数实现以下异步控制流


6. 实现串行（一个接一个的）发送10个请求，来获取前10页数据


7. 实现并行（同时）发送10个请求，来获取前10页数据


8. 请使用之前作业：Promise 实现的 ajaxGet(url) 使用 async/await 实现以下异步控制流


实现串行（一个接一个的）发送10个请求，来获取前10页数据
实现并行（同时）发送10个请求，来获取前10页数据


源码阅读题:
此题为选做题，请阅读 co 源码，必要的地方加上注释。请将你标注的代码提交，并写一个文档介绍这个包的原理

此包的源码可以在 https://github.com/tj/co 获得