问答题：
1. 为什么要使用 generator 函数 或者 async/await 进行异步控制流，对比 callback 和 Promise 方案，主要解决了什么问题？
为了解决JS用事件+回调函数的机制满足异步操作，导致异步操作多了以后，代码横向发展，嵌套层数太多，导致难以调试和阅读。
Promise虽然能够解决回调地狱的问题，但是代码过于冗长。


2. generator 函数为什么能实现异步控制流？其原理是什么？
因为要实现异步控制流，且让它和同步流写法类似。

而这要求必须做到执行到异步操作的时候，停下函数的执行，等待异步操作完成；而等异步操作完成之后，又能重新开始执行。

而 Generator 函数能很好地满足这个要求。
它每次代码运行到 yield 右侧或者 return 结束，而只要在外部利用迭代器 next 一下就能继续执行到 yield 或者 return。


3. 什么是 Thunk 函数？为什么使用 Thunk 函数可以通过和 generator 函数配合实现异步控制流？
Thunk 函数需要输入两次参数的函数。第一次输入除了回调函数之外的所有参数，第二次输入回调函数。

在说我的理解之前，我想说一句“废话”和目标。

“废话”：JS实现异步编程最基本的方法是使用回调函数。（换话说，使用回调也往往是为了实现异步编程，同步编程往往不需要回调函数。）
目标：实现异步控制流————像写同步编程那样进行异步编程。 （将回调函数从异步控制流中剥离，从而避免回调地狱）

以下为 Thunk 函数与 generator 函数如何配合实现异步控制流的回答：

根据前面那句“废话”，同步和异步最大的区别在于需不需要回调函数。

试想，如果异步函数调用后能取得结果并且存储在一个变量，也就是写成这样的形式。

let data = asynFun(arg1,arg2,callback) // 在执行到这条代码是能够正确获得数据

那就不需要回调函数了，也就和普通的同步代码没区别。
当我们都知道，这样的函数一定会失败，因为异步操作需要时间，而一般的同步流不会停止，它会继续向下执行，所以 data 里什么都没有。

但是已经有目标和方向了。就是去解决那些让那行代码执行的和我们想要结果不太一样的原因。        

这需要我们完成四件事。

一：执行到异步函数的停止，直到异步函数执行完成。
二：等异步函数执行完成之后，重新开始执行 
三：取得异步函数执行完成的结果。
四：将结果赋予一个变量。


接下来依次看这四件事的实现方法。

第一件事，执行到异步函数停止。
这很简单，将异步函数写进 generator 函数, 用 yield 关键字就好了。
如：
```
yield asynFun(arg1,arg2,callback) 
```
或者
```
asynFun(arg1,arg2,callback) 
yield 
```

第二件事，在异步函数执行完成之后，我们需要知道，并且开始重新执行。
这可能有点问题。





能不能，把 asynFun 这个函数拆成两部分，一部分在 generator 函数里执行，另一部分在 generator函数外执行。


第三件事：


第四件事：




而 gnenerator 函数配合 yield 使用，就能实现上句话中的“赋予左值”。
因为 yield 能暂停 generator 函数执行直至异步操作完成，生成结果。还能用 generator 函数生成的迭代器的 next 方法将异步函数的结果返回到




这个时候，我们已经不需要回调函数了————只要能将它中的执行结果赋给yield的



因为Thunk函数将同步写法不需要的回调函数剥离，只留下同步写法需要的其他参数————毕竟回调函数本身就专门为异步操作设计。

相比原来的嵌套的写法，这样做将对异步操作获得的数据操作的代码写在两个 yield 或者 yield 和 return 之间，而不是回调函数中。

但是异步操作依旧需要回调函数，否则无法开始执行。

因而就需要 yield 将输入了第一次参数的异步操作函数输出。

然后在在外设置回调函数，并在其中使用迭代器的 next 方法取到异步操作执行完成后的数据，
这样异步操作函数的第二次回调函数参数就设置完成，并开始执行。





那么生成器之外的那个回调函数，给下一个

给个场景和画张图表示




4. 使用 Promise 可以配合 generator 函数实现异步控制流吗？具体原理是什么？

可以。




5. 真正发出异步操作指令是在 generator 函数外还是在 generator 函数内？（hint: 基于 Thunk 函数和基于 Promise 两种 generator 函数异步控制流，情况不一样）



6. async 函数是什么？它和 generator 函数有什么关系？



7. 在全局域或者普通函数中能使用 await 或 yield 关键字吗？为什么？
不能。


8. 直接调用 async 函数的返回值类型是什么？为什么？
返回值的内容是Promise。


9. 下面代码能正常捕获异步异常吗？为什么？如果不能需要怎样修改才可以正常捕获异常？
```
async function f() {
   throw new Error('出错了');
}
try{
   f()
}catch(e){
   console.log(e)
}
```

代码题：
1. 请实现 thunkify(fn) 函数，它将一个 callback 类型的异步调用函数转换为 Thunk 函数


2. 请将 fs.readFile(path[, options], callback) 函数 Thunk 化，了解函数点击这里


3. 请实现基于 Thunk 函数的 generator 函数自动运行器


4. 请实现基于 Promise 的 generator 函数自动运行器


5. 请使用之前作业：Promise 实现的 ajaxGet(url) 使用 generator 函数实现以下异步控制流


6. 实现串行（一个接一个的）发送10个请求，来获取前10页数据


7. 实现并行（同时）发送10个请求，来获取前10页数据


8. 请使用之前作业：Promise 实现的 ajaxGet(url) 使用 async/await 实现以下异步控制流
   实现串行（一个接一个的）发送10个请求，来获取前10页数据
   实现并行（同时）发送10个请求，来获取前10页数据


源码阅读题:
此题为选做题，请阅读 co 源码，必要的地方加上注释。请将你标注的代码提交，并写一个文档介绍这个包的原理

此包的源码可以在 https://github.com/tj/co 获得